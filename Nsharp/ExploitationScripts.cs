using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;

namespace Nsharp
{
    public class ScriptResult
    {
        public int Port { get; set; }
        public string VulnerabilityInfo { get; set; } = string.Empty;
    }

    public static class ExploitationScripts
    {
        public static List<ScriptResult> RunScript(string scriptName, string host, List<ScanResult> openPorts, int timeout)
        {
            return scriptName.ToLower() switch
            {
                "ftp-anon" => CheckFTPAnonymous(host, openPorts, timeout),
                "smb-vuln" => CheckSMBVulnerabilities(host, openPorts, timeout),
                "ssh-auth" => CheckSSHAuthentication(host, openPorts, timeout),
                "http-methods" => CheckHTTPMethods(host, openPorts, timeout),
                "mysql-empty-password" => CheckMySQLEmptyPassword(host, openPorts, timeout),
                "default-creds" => CheckDefaultCredentials(host, openPorts, timeout),
                _ => new List<ScriptResult> { new ScriptResult { Port = 0, VulnerabilityInfo = $"Unknown script: {scriptName}" } }
            };
        }

        private static List<ScriptResult> CheckFTPAnonymous(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var ftpPorts = openPorts.Where(p => p.Port == 21 || p.Service == "ftp").ToList();

            foreach (var port in ftpPorts)
            {
                var result = new ScriptResult { Port = port.Port };

                try
                {
                    using var client = new TcpClient();
                    if (!client.ConnectAsync(host, port.Port).Wait(timeout))
                    {
                        result.VulnerabilityInfo = "Connection timeout";
                        results.Add(result);
                        continue;
                    }

                    using var stream = client.GetStream();
                    stream.ReadTimeout = timeout;

                    var buffer = new byte[1024];
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    if (bytesRead > 0)
                    {
                        // Read banner (discard for now)
                    }

                    // Try anonymous login
                    var userCommand = Encoding.ASCII.GetBytes("USER anonymous\r\n");
                    stream.Write(userCommand, 0, userCommand.Length);
                    bytesRead = stream.Read(buffer, 0, buffer.Length);
                    if (bytesRead > 0)
                    {
                        var response = Encoding.ASCII.GetString(buffer, 0, bytesRead);

                        if (response.StartsWith("331")) // User OK, need password
                        {
                            var passCommand = Encoding.ASCII.GetBytes("PASS anonymous@example.com\r\n");
                            stream.Write(passCommand, 0, passCommand.Length);
                            bytesRead = stream.Read(buffer, 0, buffer.Length);
                            if (bytesRead > 0)
                            {
                                response = Encoding.ASCII.GetString(buffer, 0, bytesRead);

                                if (response.StartsWith("230")) // Login successful
                                {
                                    result.VulnerabilityInfo = "VULNERABLE: Anonymous FTP login allowed";
                                }
                                else
                                {
                                    result.VulnerabilityInfo = "Anonymous FTP login not allowed";
                                }
                            }
                        }
                        else
                        {
                            result.VulnerabilityInfo = "Anonymous user not accepted";
                        }
                    }
                }
                catch (Exception ex)
                {
                    result.VulnerabilityInfo = $"Error: {ex.Message}";
                }

                results.Add(result);
            }

            return results;
        }

        private static List<ScriptResult> CheckSMBVulnerabilities(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var smbPorts = openPorts.Where(p => p.Port == 445 || p.Port == 139).ToList();

            foreach (var port in smbPorts)
            {
                var result = new ScriptResult 
                { 
                    Port = port.Port,
                    VulnerabilityInfo = "SMB detected - Potential targets: EternalBlue (MS17-010), SMBGhost (CVE-2020-0796)"
                };
                results.Add(result);
            }

            return results;
        }

        private static List<ScriptResult> CheckSSHAuthentication(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var sshPorts = openPorts.Where(p => p.Port == 22 || p.Service == "ssh").ToList();

            foreach (var port in sshPorts)
            {
                var result = new ScriptResult { Port = port.Port };

                try
                {
                    using var client = new TcpClient();
                    if (!client.ConnectAsync(host, port.Port).Wait(timeout))
                    {
                        result.VulnerabilityInfo = "Connection timeout";
                        results.Add(result);
                        continue;
                    }

                    using var stream = client.GetStream();
                    stream.ReadTimeout = timeout;

                    var buffer = new byte[1024];
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    if (bytesRead > 0)
                    {
                        var banner = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                        result.VulnerabilityInfo = $"SSH Banner: {banner.Trim()}";

                        // Check for known vulnerable versions
                        if (banner.Contains("OpenSSH_7.2") || banner.Contains("OpenSSH_7.3"))
                        {
                            result.VulnerabilityInfo += " - POTENTIALLY VULNERABLE: CVE-2016-6210 (User enumeration)";
                        }
                    }
                }
                catch (Exception ex)
                {
                    result.VulnerabilityInfo = $"Error: {ex.Message}";
                }

                results.Add(result);
            }

            return results;
        }

        private static List<ScriptResult> CheckHTTPMethods(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var httpPorts = openPorts.Where(p => p.Port == 80 || p.Port == 443 || p.Port == 8080 || 
                                                   p.Service == "http" || p.Service == "https").ToList();

            foreach (var port in httpPorts)
            {
                var result = new ScriptResult { Port = port.Port };

                try
                {
                    using var client = new TcpClient();
                    if (!client.ConnectAsync(host, port.Port).Wait(timeout))
                    {
                        result.VulnerabilityInfo = "Connection timeout";
                        results.Add(result);
                        continue;
                    }

                    using var stream = client.GetStream();
                    stream.ReadTimeout = timeout;

                    // Send OPTIONS request
                    var request = Encoding.ASCII.GetBytes("OPTIONS / HTTP/1.0\r\n\r\n");
                    stream.Write(request, 0, request.Length);

                    var buffer = new byte[4096];
                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                    if (bytesRead > 0)
                    {
                        var response = Encoding.ASCII.GetString(buffer, 0, bytesRead);

                        if (response.Contains("Allow:"))
                        {
                            var allowLine = response.Split('\n').FirstOrDefault(l => l.StartsWith("Allow:"));
                            if (allowLine != null)
                            {
                                result.VulnerabilityInfo = $"HTTP Methods: {allowLine.Substring(6).Trim()}";
                                
                                if (allowLine.Contains("PUT") || allowLine.Contains("DELETE"))
                                {
                                    result.VulnerabilityInfo += " - WARNING: Dangerous methods enabled";
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    result.VulnerabilityInfo = $"Error: {ex.Message}";
                }

                results.Add(result);
            }

            return results;
        }

        private static List<ScriptResult> CheckMySQLEmptyPassword(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var mysqlPorts = openPorts.Where(p => p.Port == 3306 || p.Service == "mysql").ToList();

            foreach (var port in mysqlPorts)
            {
                var result = new ScriptResult 
                { 
                    Port = port.Port,
                    VulnerabilityInfo = "MySQL detected - Consider testing for default/empty passwords (root:root, root:, etc.)"
                };
                results.Add(result);
            }

            return results;
        }

        private static List<ScriptResult> CheckDefaultCredentials(string host, List<ScanResult> openPorts, int timeout)
        {
            var results = new List<ScriptResult>();
            var defaultCreds = new Dictionary<string, List<(string user, string pass)>>
            {
                { "ftp", new List<(string, string)> { ("anonymous", "anonymous"), ("admin", "admin"), ("ftp", "ftp") } },
                { "ssh", new List<(string, string)> { ("root", "root"), ("admin", "admin"), ("user", "user") } },
                { "telnet", new List<(string, string)> { ("admin", "admin"), ("root", "root") } }
            };

            foreach (var port in openPorts)
            {
                var service = port.Service.ToLower();
                
                if (defaultCreds.ContainsKey(service))
                {
                    var result = new ScriptResult 
                    { 
                        Port = port.Port,
                        VulnerabilityInfo = $"Consider testing default credentials for {service}"
                    };
                    results.Add(result);
                }
            }

            return results;
        }
    }
}
